<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Gestionnaires de processus pour les applications Express</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Gestionnaires de processus pour les applications Express</h1>
</header>
<h1 id="gestionnaires-de-processus-pour-les-applications-express">Gestionnaires de processus pour les applications Express</h1>
<p>Quand vous exécutez l’application Express pour la production, utilisez un <em>gestionnaire de processus</em> car celui-ci peut vous permettre :</p>
<ul>
<li>De redémarrer l’application manuellement si elle subit une panne.</li>
<li>De vous informer sur les performances d’exécution et la consommation des ressources.</li>
<li>De modifier les paramètres de manière dynamique afin d’améliorer les performances.</li>
<li>De contrôler la mise en cluster.</li>
</ul>
<p>Un gestionnaire de processus est quelque sorte un “conteneur” d’applications qui facilite le déploiement, offre une haute disponibilité et vous permet de gérer l’application lors de son exécution.</p>
<p>Les gestionnaires de processus les plus populaires pour Express et d’autres applications Node.js sont les suivants :</p>
<ul>
<li><a href="#sl">StrongLoop Process Manager</a></li>
<li><a href="#pm2">PM2</a></li>
<li><a href="#forever">Forever</a></li>
</ul>
<p>L’utilisation d’un de ces trois outils peut être très utile, cependant le gestionnaire de processus StrongLoop est le seul qui fournisse un délai d’exécution exhaustif ainsi qu’une solution de déploiement qui s’adresse à l’intégralité du cycle de vie de l’application, avec des outils pour chaque étape avant et après la production, le tout dans une interface unifiée.</p>
<p>Voici un bref aperçu de chacun de ces outils. Pour une comparaison détaillée, voir <a href="http://strong-pm.io/compare/">http://strong-pm.io/compare/</a>.</p>
<h2 id="strongloop-process-manager"><a id="sl">StrongLoop Process Manager</a></h2>
<p>Le gestionnaire de processus StrongLoop (StrongLoop PM) est un gestionnaire de processus de production pour les applications Node.js. StrongLoop PM possède un équilibrage de charge, une surveillance et un déploiement multi-hôte, ainsi qu’une console graphique intégrés. Vous pouvez utiliser StrongLoop PM pour les tâches suivantes :</p>
<ul>
<li>Construire, combiner et déployer votre application Node.js à un système local ou distant.</li>
<li>Afficher les profils d’UC et les instantanés de segment de mémoire pour optimiser les performances et diagnostiquer les fuites de mémoire.</li>
<li>Conserver des processus et des clusters avec une durée de vie illimitée.</li>
<li>Afficher les indicateurs de performance dans votre application.</li>
<li>Gérer facilement les déploiements multi-hôtes avec l’intégration Nginx.</li>
<li>Unifier plusieurs StrongLoop PM avec un délai d’exécution des microservices réparti et qui est géré par Arc.</li>
</ul>
<p>Vous pouvez utiliser StrongLoop PM en passant par un puissant outil d’interface de ligne de commande appelé <code>slc</code>, ou un outil graphique appelé Arc. Arc est un code source ouvert, avec une prise en charge professionnelle fournie par StrongLoop.</p>
<p>Pour plus d’informations, voir <a href="http://strong-pm.io/">http://strong-pm.io/</a>.</p>
<p>Documentation complète :</p>
<ul>
<li><a href="http://docs.strongloop.com/display/SLC">Utilisation des applications Node (documentation StrongLoop)</a></li>
<li><a href="http://docs.strongloop.com/display/SLC/Using+Process+Manager">Utilisation du gestionnaire de processus StrongLoop</a>.</li>
</ul>
<h3 id="installation">Installation</h3>
<pre>
<code class="language-sh" translate="no">
$ [sudo] npm install -g strongloop
</code>
</pre>
<h3 id="utilisation-de-base">Utilisation de base</h3>
<pre>
<code class="language-sh" translate="no">
$ cd my-app
$ slc start
</code>
</pre>
<p>Afficher le statut du gestionnaire de processus ainsi que de toutes les applications déployées :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl
Service ID: 1
Service Name: my-app
Environment variables:
  No environment variables defined
Instances:
    Version  Agent version  Cluster size
     4.1.13      1.5.14           4
Processes:
        ID      PID   WID  Listening Ports  Tracking objects?  CPU profiling?
    1.1.57692  57692   0
    1.1.57693  57693   1     0.0.0.0:3001
    1.1.57694  57694   2     0.0.0.0:3001
    1.1.57695  57695   3     0.0.0.0:3001
    1.1.57696  57696   4     0.0.0.0:3001
</code>
</pre>
<p>Lister toutes les applications (services) sous gestion :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl ls
Id          Name         Scale
 1          my-app       1
</code>
</pre>
<p>Arrêter une application :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl stop my-app
</code>
</pre>
<p>Redémarrer une application :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl restart my-app
</code>
</pre>
<p>Vous pouvez également “redémarrer en douceur”, ce qui donne aux processus de traitement un délai supplémentaire afin de fermer les connexions existantes, et permet un redémarrage des applications en cours :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl soft-restart my-app
</code>
</pre>
<p>Supprimer une application de la gestion :</p>
<pre>
<code class="language-sh" translate="no">
$ slc ctl remove my-app
</code>
</pre>
<h2 id="pm2"><a id="pm2">PM2</a></h2>
<p>PM2 est un gestionnaire de processus de production pour les applications Node.js, qui possède un équilibreur de charge intégré. PM2 vous permet de conserver des applications avec une durée de vie illimitée et de les recharger sans temps d’arrêt, ce qui facilite les tâches de l’administrateur système commun. PM2 vous permet également de gérer la journalisation, la surveillance et le regroupement de l’application.</p>
<p>Pour plus d’informations, voir <a href="https://github.com/Unitech/pm2">https://github.com/Unitech/pm2</a>.</p>
<h3 id="installation-1">Installation</h3>
<pre>
<code class="language-sh" translate="no">
$ [sudo] npm install pm2 -g
</code>
</pre>
<h3 id="utilisation-de-base-1">Utilisation de base</h3>
<p>Quand vous démarrez une application en utilisant la commande <code>pm2</code> vous devez indiquer le chemin d’accès de l’application. Cependant, quand vous arrêtez, redémarrez ou supprimez une application, vous pouvez n’indiquer que le nom ou l’ID de l’application.</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 start npm --name my-app -- start
[PM2] restartProcessId process id 0
┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────────────┬──────────┐
│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ memory      │ watching │
├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────────────┼──────────┤
│ my-app   │ 0  │ fork │ 64029 │ online │ 1       │ 0s     │ 17.816 MB   │ disabled │
└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────────────┴──────────┘
 Use the `pm2 show <id|name>` command to get more details about an app.
</code>
</pre>
<p>Quand vous démarrez une application à l’aide de la commande <code>pm2</code>, l’application est immédiatement envoyée en arrière-plan. Vous pouvez contrôler l’application en arrière-plan à partir de la ligne de commande en utilisant diverses commandes <code>pm2</code>.</p>
<p>Après qu’une application a été démarrée en utilisant la commande <code>pm2</code>, elle est enregistrée dans la liste de processus de PM2 avec un ID. Vous pouvez donc gérer les applications avec le même nom à partir de répertoires différents dans le système, en utilisant leurs ID.</p>
<p>Notez que si plusieurs application avec le même nom sont en cours d’exécution, les commandes <code>pm2</code> les affecteront toutes. Il vaut donc mieux utiliser les ID plutôt que les noms pour gérer les applications individuelles.</p>
<p>Lister tous les processus en cours :</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 list
</code>
</pre>
<p>Arrêter une application :</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 stop 0
</code>
</pre>
<p>Redémarrer une application :</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 restart 0
</code>
</pre>
<p>Pour afficher les informations détaillées d’une application :</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 show 0
</code>
</pre>
<p>Pour supprimer une application du registre PM2 :</p>
<pre>
<code class="language-sh" translate="no">
$ pm2 delete 0
</code>
</pre>
<h2 id="forever"><a id="forever">Forever</a></h2>
<p>Forever est un simple outil d’interface de ligne de commande qui permet de s’assurer qu’un script donné est exécuté de façon continue (forever). L’interface simple de Forever en fait un outil idéal pour exécuter des déploiements plus petits des applications et des scripts de Node.jps.</p>
<p>Pour plus d’informations, voir <a href="https://github.com/foreverjs/forever">https://github.com/foreverjs/forever</a>.</p>
<h3 id="installation-2">Installation</h3>
<pre>
<code class="language-sh" translate="no">
$ [sudo] npm install forever -g
</code>
</pre>
<h3 id="utilisation-de-base-2">Utilisation de base</h3>
<p>Pour démarrer un script, utilisez la commande <code>forever start</code> et indiquez le chemin d’accès du script :</p>
<pre>
<code class="language-sh" translate="no">
$ forever start script.js
</code>
</pre>
<p>Cette commande exécutera le script en mode démon (à l’arrière-plan).</p>
<p>Pour exécuter le script de façon à ce qu’il soit joint au terminal, il ne faut pas prendre en compte <code>start</code> :</p>
<pre>
<code class="language-sh" translate="no">
$ forever script.js
</code>
</pre>
<p>C’est une bonne idée de consigner votre sortie du script et de l’outil Forever en utilisant les options de consignation <code>-l</code>, <code>-o</code> et <code>-e</code>, comme illustré dans l’exemple suivant :</p>
<pre>
<code class="language-sh" translate="no">
$ forever start -l forever.log -o out.log -e err.log script.js
</code>
</pre>
<p>Pour visualiser la liste des scripts qui ont été démarrés par Forever :</p>
<pre>
<code class="language-sh" translate="no">
$ forever list
</code>
</pre>
<p>Pour arrêter un script qui a été démarré par Forever, utilisez la commande <code>forever stop</code> et indiquez l’index de processus (tel qu’il est listé par la commande <code>forever list</code>).</p>
<pre>
<code class="language-sh" translate="no">
$ forever stop 1
</code>
</pre>
<p>Sinon, indiquez le chemin d’accès du fichier :</p>
<pre>
<code class="language-sh" translate="no">
$ forever stop script.js
</code>
</pre>
<p>Pour arrêter tous les scripts qui ont été démarrés par Forever :</p>
<pre>
<code class="language-sh" translate="no">
$ forever stopall
</code>
</pre>
<p>Forever possède beaucoup d’autres options, et il fournit également une API programmable.</p>
</body>
</html>
