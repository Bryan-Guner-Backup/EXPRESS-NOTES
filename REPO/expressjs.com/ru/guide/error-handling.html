<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Обработка ошибок в Express</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Обработка ошибок в Express</h1>
</header>
<h1 id="обработка-ошибок">Обработка ошибок</h1>
<p>Функции промежуточного обработчика для обработки ошибок определяются так же, как и другие функции промежуточной обработки, но с указанием для функции обработки ошибок не трех, а четырех аргументов: <code>(err, req, res, next)</code>. Например:</p>
<pre>
<code class="language-javascript" translate="no">
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</code>
</pre>
<p>Промежуточный обработчик для обработки ошибок должен быть определен последним, после указания всех <code>app.use()</code> и вызовов маршрутов; например:</p>
<pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(function(err, req, res, next) {
  // logic
});
</code>
</pre>
<p>Ответы, поступающие из функции промежуточной обработки, могут иметь любой формат, в зависимости от ваших предпочтений. Например, это может быть страница сообщения об ошибке HTML, простое сообщение или строка JSON.</p>
<p>В целях упорядочения (и для фреймворков более высокого уровня) можно определить несколько функций промежуточной обработки ошибок, точно так же, как это допускается для обычных функций промежуточной обработки. Например, для того чтобы определить обработчик ошибок для запросов, совершаемых с помощью <code>XHR</code>, и для остальных запросов, можно воспользоваться следующими командами:</p>
<pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
</code>
</pre>
<p>В данном примере базовый код <code>logErrors</code> может записывать информацию о запросах и ошибках в <code>stderr</code>, например:</p>
<pre>
<code class="language-javascript" translate="no">
function logErrors(err, req, res, next) {
  console.error(err.stack);
  next(err);
}
</code>
</pre>
<p>Кроме того, в данном примере <code>clientErrorHandler</code> определен, как указано ниже; в таком случае ошибка явным образом передается далее следующему обработчику:</p>
<pre>
<code class="language-javascript" translate="no">
function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' });
  } else {
    next(err);
  }
}
</code>
</pre>
<p>“Обобщающая” функция <code>errorHandler</code> может быть реализована так:</p>
<pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
<p>При передаче какого-либо объекта в функцию <code>next()</code> (кроме строки <code>'route'</code>), Express интерпретирует текущий запрос как ошибку и пропустит все остальные функции маршрутизации и промежуточной обработки, не являющиеся функциями обработки ошибок. Для того чтобы обработать данную ошибку определенным образом, необходимо создать маршрут обработки ошибок, как описано в следующем разделе.</p>
<p>Если задан обработчик ошибок с несколькими функциями обратного вызова, можно воспользоваться параметром <code>route</code>, чтобы перейти к следующему обработчику маршрута. Например:</p>
<pre>
<code class="language-javascript" translate="no">
app.get('/a_route_behind_paywall',
  function checkIfPaidSubscriber(req, res, next) {
    if(!req.user.hasPaid) {

      // continue handling this request
      next('route');
    }
  }, function getPaidContent(req, res, next) {
    PaidContent.find(function(err, doc) {
      if(err) return next(err);
      res.json(doc);
    });
  });
</code>
</pre>
<p>В данном примере обработчик <code>getPaidContent</code> будет пропущен, но выполнение всех остальных обработчиков в <code>app</code> для <code>/a_route_behind_paywall</code> будет продолжено.</p>
<div class="doc-box doc-info" data-markdown="1">
<p>Вызовы <code>next()</code> и <code>next(err)</code> указывают на завершение выполнения текущего обработчика и на его состояние. <code>next(err)</code> пропускает все остальные обработчики в цепочке, кроме заданных для обработки ошибок, как описано выше.</p>
</div>
<h2 id="стандартный-обработчик-ошибок">Стандартный обработчик ошибок</h2>
<p>В Express предусмотрен встроенный обработчик ошибок, который обрабатывает любые возможные ошибки, встречающиеся в приложении. Этот стандартный обработчик ошибок добавляется в конец стека функций промежуточной обработки.</p>
<p>В случае передачи ошибки в <code>next()</code> без обработки с помощью обработчика ошибок, такая ошибка будет обработана встроенным обработчиком ошибок. Ошибка будет записана на клиенте с помощью трассировки стека. Трассировка стека не включена в рабочую среду.</p>
<div class="doc-box doc-info" data-markdown="1">
<p>Для запуска приложения в рабочем режиме необходимо задать для переменной среды <code>NODE_ENV</code> значение <code>production</code>.</p>
</div>
<p>При вызове <code>next()</code> с ошибкой после начала записи ответа (например, если ошибка обнаружена во время включения ответа в поток, направляемый клиенту), стандартный обработчик ошибок Express закрывает соединение и отклоняет запрос.</p>
<p>Поэтому при добавлении нестандартного обработчика ошибок вам потребуется делегирование в стандартные механизмы обработки ошибок в Express в случае, если заголовки уже были отправлены клиенту:</p>
<pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  if (res.headersSent) {
    return next(err);
  }
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
</body>
</html>
