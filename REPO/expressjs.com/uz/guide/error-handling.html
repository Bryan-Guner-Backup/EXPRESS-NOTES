<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="uz" xml:lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Express error handling</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Express error handling</h1>
</header>
<h1 id="error-handling">Error handling</h1>
<p>Define error-handling middleware like other middleware, except with four arguments instead of three, specifically with the signature <code>(err, req, res, next)</code>):</p>
<pre><code class="language-javascript" translate="no">
app.use(function(err, req, res, next){
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</code></pre>
<p>You define error-handling middleware last, after other <code>app.use()</code> and routes calls; For example:</p>
<pre><code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(function(err, req, res, next){
  // logic
});
</code></pre>
<p>Responses from within the middleware are completely arbitrary. You may wish to respond with an HTML error page, a simple message, a JSON string, or anything else you prefer.</p>
<p>For organizational (and higher-level framework) purposes, you may define several error-handling middleware, much like you would with regular middleware. For example suppose you wanted to define an error-handler for requests made via XHR, and those without, you might do:</p>
<pre><code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
</code></pre>
<p>Where the more generic <code>logErrors</code> may write request and error information to stderr, loggly, or similar services:</p>
<pre><code class="language-javascript" translate="no">
function logErrors(err, req, res, next) {
  console.error(err.stack);
  next(err);
}
</code></pre>
<p>Where <code>clientErrorHandler</code> is defined as the following (note that the error is explicitly passed along to the next):</p>
<pre><code class="language-javascript" translate="no">
function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something blew up!' });
  } else {
    next(err);
  }
}
</code></pre>
<p>The following <code>errorHandler</code> “catch-all” implementation may be defined as:</p>
<pre><code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
}
</code></pre>
</body>
</html>
