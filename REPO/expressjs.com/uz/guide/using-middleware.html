<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="uz" xml:lang="uz">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Using Express middleware</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Using Express middleware</h1>
    </header>
    <h1 id="using-middleware">Using middleware</h1>
    <p>An Express application is essentially a series of middleware calls.</p>
    <p>
      Middleware is a function with access to the request object
      (<code>req</code>), the response object (<code>res</code>), and the next
      middleware in line in the request-response cycle of an Express
      application, commonly denoted by a variable named <code>next</code>.
      Middleware can:
    </p>
    <ul>
      <li>Execute any code.</li>
      <li>Make changes to the request and the response objects.</li>
      <li>End the request-response cycle.</li>
      <li>Call the next middleware in the stack.</li>
    </ul>
    <p>
      If the current middleware does not end the request-response cycle, it must
      call <code>next()</code> to pass control to the next middleware, otherwise
      the request will be left hanging.
    </p>
    <p>
      With an optional mount path, middleware can be loaded at the application
      level or at the router level. Also, a series of middleware functions can
      be loaded together, creating a sub-stack of the middleware system at a
      mount point.
    </p>
    <p>An Express application can use the following kinds of middleware:</p>
    <ul>
      <li>
        <a href="#middleware.application">Application-level middleware</a>
      </li>
      <li><a href="#middleware.router">Router-level middleware</a></li>
      <li><a href="#middleware.built-in">Built-in middleware</a></li>
      <li><a href="#middleware.third-party">Third-party middleware</a></li>
    </ul>
    <h3 id="middleware.application">Application level middleware</h3>
    <p>
      Application level middleware are bound to an instance of
      <code>express</code>, using <code>app.use()</code> and
      <code>app.VERB()</code>.
    </p>
    <pre><code class="language-javascript" translate="no">
var app = express();

// a middleware with no mount path; gets executed for every request to the app
app.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

// a middleware mounted on /user/:id; will be executed for any type of HTTP request to /user/:id
app.use('/user/:id', function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});

// a route and its handler function (middleware system) which handles GET requests to /user/:id
app.get('/user/:id', function (req, res, next) {
  res.send('USER');
});
</code></pre>
    <p>
      Here is an example of loading a series of middleware at a mount point with
      a mount path.
    </p>
    <pre><code class="language-javascript" translate="no">
// a middleware sub-stack which prints request info for any type of HTTP request to /user/:id
app.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});
</code></pre>
    <p>
      Route handlers, being a middleware system, makes it possible to define
      multiple routes for a path. In the example below, two routes are defined
      for GET requests to <code>/user/:id</code>. The second router will not
      cause any problems, however it will never get called, because the first
      route ends the request-response cycle.
    </p>
    <pre><code class="language-javascript" translate="no">
// a middleware sub-stack which handles GET requests to /user/:id
app.get('/user/:id', function (req, res, next) {
  console.log('ID:', req.params.id);
  next();
}, function (req, res, next) {
  res.send('User Info');
});

// handler for /user/:id which prints the user id
app.get('/user/:id', function (req, res, next) {
  res.end(req.params.id);
});
</code></pre>
    <p>
      If you need to skip the rest of the middleware from a router middleware
      stack, call <code>next('route')</code> to pass on the control to the next
      route. Note: <code>next('route')</code> will work only in middleware
      loaded using <code>app.VERB()</code> or <code>router.VERB()</code>.
    </p>
    <pre><code class="language-javascript" translate="no">
// a middleware sub-stack which handles GET requests to /user/:id
app.get('/user/:id', function (req, res, next) {
  // if user id is 0, skip to the next route
  if (req.params.id == 0) next('route');
  // else pass the control to the next middleware in this stack
  else next(); //
}, function (req, res, next) {
  // render a regular page
  res.render('regular');
});

// handler for /user/:id which renders a special page
app.get('/user/:id', function (req, res, next) {
  res.render('special');
});
</code></pre>
    <h3 id="middleware.router">Router level middleware</h3>
    <p>
      Router level middleware work just like application level middleware except
      they are bound to an instance of <code>express.Router()</code>.
    </p>
    <pre><code class="language-javascript" translate="no">
var router = express.Router();
</code></pre>
    <p>
      Router level middleware are loaded using <code>router.use()</code> and
      <code>router.VERB()</code>.
    </p>
    <p>
      The middleware system created at the application level in the example
      above, can be replicated at the router level using the following code.
    </p>
    <pre><code class="language-javascript" translate="no">
var app = express();
var router = express.Router();

// a middleware with no mount path, gets executed for every request to the router
router.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

// a middleware sub-stack shows request info for any type of HTTP request to /user/:id
router.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});

// a middleware sub-stack which handles GET requests to /user/:id
router.get('/user/:id', function (req, res, next) {
  // if user id is 0, skip to the next router
  if (req.params.id == 0) next('route');
  // else pass the control to the next middleware in this stack
  else next(); //
}, function (req, res, next) {
  // render a regular page
  res.render('regular');
});

// handler for /user/:id which renders a special page
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id);
  res.render('special');
});

// mount the router on the app
app.use('/', router);
</code></pre>
    <h3 id="middleware.built-in">Built-in middleware</h3>
    <p>
      As of 4.x, Express no longer depends on Connect. Except for
      <code>express.static</code>, all of Express’ previously included
      middleware are now in separate repos. Please view
      <a href="https://github.com/senchalabs/connect#middleware"
        >the list of middleware</a
      >.
    </p>
    <h4 id="express.static">express.static(root, [options])</h4>
    <p>
      <code>express.static</code> is based on
      <a href="https://github.com/expressjs/serve-static">serve-static</a>, and
      is responsible for serving the static assets of an Express application.
    </p>
    <p>
      The <code>root</code> argument refers to the root directory from which the
      static assets are to be served.
    </p>
    <p>
      The optional <code>options</code> object can have the following
      properties.
    </p>
    <ul>
      <li>
        <code>dotfiles</code> option for serving dotfiles. Possible values are
        “allow”, “deny”, and “ignore”; defaults to “ignore”.
      </li>
      <li>
        <code>etag</code> enable or disable etag generation, defaults to
        <code>true</code>.
      </li>
      <li>
        <code>extensions</code> sets file extension fallbacks, defaults to
        <code>false</code>.
      </li>
      <li>
        <code>index</code> sends directory index file, defaults to “index.html”.
        Set <code>false</code> to disable directory indexing.
      </li>
      <li>
        <code>lastModified</code> enabled by default, sets the
        <code>Last-Modified</code> header to the last modified date of the file
        on the OS. Set <code>false</code> to disable it.
      </li>
      <li>
        <code>maxAge</code> sets the max-age property of the Cache-Control
        header in milliseconds or a string in
        <a href="https://www.npmjs.org/package/ms">ms format</a>, defaults to 0.
      </li>
      <li>
        <code>redirect</code> redirects to trailing “/” when the pathname is a
        dir, defaults to <code>true</code>.
      </li>
      <li>
        <code>setHeaders</code> function for setting HTTP headers to serve with
        the file.
      </li>
    </ul>
    <p>
      Here is an example of using the <code>express.static</code> middleware
      with an elaborate options object.
    </p>
    <pre><code class="language-javascript" translate="no">
var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
};

app.use(express.static('public', options));
</code></pre>
    <p>You can have more than one static directory per app.</p>
    <pre><code class="language-javascript" translate="no">
app.use(express.static('public'));
app.use(express.static('uploads'));
app.use(express.static('files'));
</code></pre>
    <p>
      For more details about <code>serve-static</code> and its options, visit
      the
      <a href="https://github.com/expressjs/serve-static">serve-static</a>
      documentation.
    </p>
    <h3 id="middleware.third-party">Third-party middleware</h3>
    <p>
      Express is a routing and middleware web framework with minimal
      functionality of its own. Functionality to Express apps are added via
      third-party middleware.
    </p>
    <p>
      Install the node module for the required functionality and loaded it in
      your app at the application level or at the router level.
    </p>
    <p>
      In the following example, <code>cookie-parser</code>, a cookie parsing
      middleware is installed and loaded in the app.
    </p>
    <pre><code class="language-sh" translate="no">
$ npm install cookie-parser
</code></pre>
    <pre><code class="language-javascript" translate="no">
var express = require('express');
var app = express();
var cookieParser = require('cookie-parser');

// load the cookie parsing middleware
app.use(cookieParser());
</code></pre>
    <p>
      See <a href="../resources/middleware.html">Third-party middleware</a> for
      a partial list of third-party middleware commonly used with Express.
    </p>
  </body>
</html>
