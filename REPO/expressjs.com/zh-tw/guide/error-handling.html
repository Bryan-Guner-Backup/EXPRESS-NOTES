<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-tw" xml:lang="zh-tw">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Express 錯誤處理</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Express 錯誤處理</h1>
</header>
<h1 id="錯誤處理">錯誤處理</h1>
<p>錯誤處理中介軟體函數的定義方式，與其他中介軟體函數相同，差別在於錯誤處理函數的引數是四個而非三個：<code>(err, req, res, next)</code>。例如：</p>
<pre>
<code class="language-javascript" translate="no">
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</code>
</pre>
<p>您是在定義其他 <code>app.use()</code> 和路由呼叫之後，最後才定義錯誤處理中介軟體；例如：</p>
<pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(function(err, req, res, next) {
  // logic
});
</code>
</pre>
<p>中介軟體函數內的回應可以是任何您喜好的格式，如：HTML 錯誤頁面、簡式訊息或 JSON 字串。</p>
<p>為了方便組織（和更高層次的架構），您可以定義數個錯誤處理中介軟體函數，就像您處理一般中介軟體函數一樣。舉例來說，如果您想為使用及沒有使用 <code>XHR</code> 所建立的要求，各定義一個錯誤處理程式，您可以使用下列指令：</p>
<pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
</code>
</pre>
<p>在本例中，通用的 <code>logErrors</code> 可能將要求和錯誤資訊寫入至 <code>stderr</code>，例如：</p>
<pre>
<code class="language-javascript" translate="no">
function logErrors(err, req, res, next) {
  console.error(err.stack);
  next(err);
}
</code>
</pre>
<p>此外在本例中，<code>clientErrorHandler</code> 定義成如下；在此情況下，會將錯誤明確傳遞給下一個：</p>
<pre>
<code class="language-javascript" translate="no">
function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' });
  } else {
    next(err);
  }
}
</code>
</pre>
<p>“catch-all” <code>errorHandler</code> 函數的實作方式如下：</p>
<pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
<p>不論您傳遞何者給 <code>next()</code> 函數（<code>'route'</code> 字串除外），Express 都會將現行要求視為發生錯誤，且會跳過其餘任何的非錯誤處理路由和中介軟體函數。如果您想以某種方式來處理該錯誤，您必須按照下一節的說明來建立錯誤處理路由。</p>
<p>如果您的路由處理程式有多個回呼函數，可以使用 <code>route</code> 參數來跳到下一個路由處理程式。例如：</p>
<pre>
<code class="language-javascript" translate="no">
app.get('/a_route_behind_paywall',
  function checkIfPaidSubscriber(req, res, next) {
    if(!req.user.hasPaid) {

      // continue handling this request
      next('route');
    }
  }, function getPaidContent(req, res, next) {
    PaidContent.find(function(err, doc) {
      if(err) return next(err);
      res.json(doc);
    });
  });
</code>
</pre>
<p>在本例中，會跳過 <code>getPaidContent</code> 處理程式，但是會繼續執行 <code>app</code> 中 <code>/a_route_behind_paywall</code> 的其餘處理程式。</p>
<div class="doc-box doc-info" data-markdown="1">
呼叫 <code>next()</code> 和 <code>next(err)</code>，指出現行處理程式已完成以及處於何種狀態。除了依上述說明設定成用來處理錯誤的那些處理程式，<code>next(err)</code> 會跳過處理程式鏈中其餘所有的處理程式。
</div>
<h2 id="預設錯誤處理程式">預設錯誤處理程式</h2>
<p>Express 隨附一個內建錯誤處理常式，它會處理應用程式中可能遇到的任何錯誤。這個預設錯誤處理中介軟體函數新增於中介軟體函數堆疊尾端。</p>
<p>如果您傳遞錯誤至 <code>next()</code>，且您沒有在錯誤處理常式中處理它，將會交由內建錯誤處理常式處理；該錯誤會連同堆疊追蹤寫入至用戶端。在正式作業環境中，則不包含堆疊追蹤。</p>
<div class="doc-box doc-info" data-markdown="1">
<p>將 <code>NODE_ENV</code> 環境變數設為 <code>production</code>，以便在正式作業模式下執行應用程式。</p>
</div>
<p>在您開始撰寫回應之後，一旦在呼叫 <code>next()</code> 時才發生錯誤（例如，當您將回應串流輸出至用戶端時遇到錯誤），Express 的預設錯誤處理程式會關閉連線，並使要求失敗。</p>
<p>因此，在您新增自訂錯誤處理常式時，如果標頭已傳送給用戶端，您會希望委派給 Express 中的預設錯誤處理機制處理：</p>
<pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  if (res.headersSent) {
    return next(err);
  }
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
</body>
</html>
