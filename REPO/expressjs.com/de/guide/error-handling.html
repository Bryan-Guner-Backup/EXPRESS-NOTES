<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Fehlerbehandlung in Express</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Fehlerbehandlung in Express</h1>
    </header>
    <h1 id="fehlerbehandlung">Fehlerbehandlung</h1>
    <p>
      Middlewarefunktionen für die Fehlerbehandlung werden in derselben Weise
      definiert wie andere Middlewarefunktionen, nur, dass
      Fehlerbehandlungsfunktionen vier anstatt drei Argumente aufweisen:
      <code>(err, req, res, next)</code>. Beispiel:
    </p>
    <pre>
<code class="language-javascript" translate="no">
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</code>
</pre>
    <p>
      Middleware für die Fehlerbehandlung wird ganz zuletzt nach allen anderen
      <code>app.use()</code>- und Weiterleitungsaufrufen definiert. Beispiel:
    </p>
    <pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(function(err, req, res, next) {
  // logic
});
</code>
</pre>
    <p>
      Antworten von der Middlewarefunktion können das von Ihnen gewünschte
      Format aufweisen wie beispielsweise eine Fehlerseite im HTML-Format, eine
      einfache Nachricht oder eine JSON-Zeichenfolge.
    </p>
    <p>
      Für organisatorische Zwecke (und Frameworks der höheren Ebene) können Sie
      mehrere Middlewarefunktionen für die Fehlerbehandlung definieren, wie Sie
      dies bei regulären Middlewarefunktionen auch tun würden. Wenn Sie
      beispielsweise eine Fehlerbehandlungsroutine (Error-Handler) für
      Anforderungen über <code>XHR</code> und andere Anforderungen definieren
      wollen, können Sie die folgenden Befehle verwenden:
    </p>
    <pre>
<code class="language-javascript" translate="no">
var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
</code>
</pre>
    <p>
      In diesem Beispiel kann die generische <code>logErrors</code>-Funktion
      Anforderungs- und Fehlerinformationen in <code>stderr</code> schreiben:
    </p>
    <pre>
<code class="language-javascript" translate="no">
function logErrors(err, req, res, next) {
  console.error(err.stack);
  next(err);
}
</code>
</pre>
    <p>
      In diesem Beispiel wird <code>clientErrorHandler</code> wie folgt
      definiert. In diesem Fall wird der Fehler explizit an den nächsten
      Error-Handler übergeben:
    </p>
    <pre>
<code class="language-javascript" translate="no">
function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' });
  } else {
    next(err);
  }
}
</code>
</pre>
    <p>
      Die <code>errorHandler</code>-Funktion “catch-all” kann wie folgt
      implementiert werden:
    </p>
    <pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
    <p>
      Wenn Sie Übergaben an die Funktion <code>next()</code> vornehmen (außer
      die Zeichenfolge <code>'route'</code>), sieht Express die aktuelle
      Anforderung als Fehler an und überspringt alle verbleibenden fehlerfreien
      Behandlungsroutinen und Middlewarefunktionen. Wenn Sie den Fehler
      bearbeiten wollen, müssen Sie (wie im nächsten Abschnitt beschrieben) eine
      Fehlerbehandlungsweiterleitung erstellen.
    </p>
    <p>
      Bei einem Routenhandler mit mehreren Callback-Funktionen können Sie den
      Parameter <code>route</code> verwenden, um den nächsten Routenhandler zu
      überspringen. Beispiel:
    </p>
    <pre>
<code class="language-javascript" translate="no">
app.get('/a_route_behind_paywall',
  function checkIfPaidSubscriber(req, res, next) {
    if(!req.user.hasPaid) {

      // continue handling this request
      next('route');
    }
  }, function getPaidContent(req, res, next) {
    PaidContent.find(function(err, doc) {
      if(err) return next(err);
      res.json(doc);
    });
  });
</code>
</pre>
    <p>
      In diesem Beispiel wird der Handler
      <code>getPaidContent</code> übersprungen. Alle verbleibenden Handler in
      <code>app</code> für <code>/a_route_behind_paywall</code> werden jedoch
      weiter ausgeführt.
    </p>
    <div class="doc-box doc-info" data-markdown="1">
      <p>
        Aufrufe zu <code>next()</code> und <code>next(err)</code> geben an, dass
        der aktuelle Handler abgeschlossen ist und welchen Status er aufweist.
        Durch <code>next(err)</code> werden alle verbleibenden Handler in der
        Kette übersprungen. Ausgenommen hiervor sind die Handler, die
        konfiguriert sind, um Fehler wie oben beschrieben zu behandeln.
      </p>
    </div>
    <h2 id="die-standardfehlerbehandlungsroutine-default-error-handler">
      Die Standardfehlerbehandlungsroutine (Default Error Handler)
    </h2>
    <p>
      Express ist bereits mit einer integrierten Fehlerbehandlungsroutine
      ausgestattet, mit der alle in der Anwendung festgestellten Fehler
      gehandhabt werden können. Diese Middleware für die Fehlerbehandlung wird
      am Ende des Middleware-Funktionsstack hinzugefügt.
    </p>
    <p>
      Wenn Sie einen Fehler an <code>next()</code> übergeben und diesen nicht
      mit einem Error-Handler bearbeiten, wird dieser über den integrierten
      Error-Handler bearbeitet. Der Fehler wird mit dem Stack-Trace zum Client
      geschrieben. Der Stack-Trace ist in der Produktionsumgebung nicht
      verfügbar.
    </p>
    <div class="doc-box doc-info" data-markdown="1">
      <p>
        Legen Sie die Umgebungsvariable <code>NODE_ENV</code> auf
        <code>production</code> fest, um die Anwendung im Produktionsmodus
        auszuführen.
      </p>
    </div>
    <p>
      Wenn <code>next()</code> mit einem Fehler aufgerufen wird, nachdem Sie mit
      dem Schreiben der Antwort begonnen haben (z. B., wenn Sie beim Streamen
      der Antwort zum Client einen Fehler feststellen), schließt die
      Standardfehlerbehandlungsroutine in Express die Verbindung, und die
      Anforderung schlägt fehl.
    </p>
    <p>
      Wenn Sie also einen angepassten Error-Handler hinzufügen, empfiehlt es
      sich, eine Delegierung zur Standardfehlerbehandlungsroutine in Express
      vorzunehmen, wenn die Header bereits an den Client gesendet wurden:
    </p>
    <pre>
<code class="language-javascript" translate="no">
function errorHandler(err, req, res, next) {
  if (res.headersSent) {
    return next(err);
  }
  res.status(500);
  res.render('error', { error: err });
}
</code>
</pre>
  </body>
</html>
